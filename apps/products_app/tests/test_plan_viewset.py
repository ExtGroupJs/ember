# Generated by CodiumAI

from datetime import datetime
import random
from django.urls import reverse
from model_bakery import baker
from rest_framework import status
from apps.products_app.models.classification import Classification
from apps.products_app.models.destination import Destination
from apps.products_app.models.entity import Entity
from apps.products_app.models.packaging import MeasurementUnit
from apps.products_app.models.plan import Plan

import pytest

from apps.products_app.models.product import Product


@pytest.mark.django_db
class TestPlanViewSet:
    # Can retrieve a list of plans with GET request
    def test_retrieve_list_of_plans(self, client):
        client.login(username="admin", password="1qazxsw2")
        baker.make(Plan, _quantity=random.randint(20, 30))
        response = client.get(reverse("plan-list"))
        # Assert
        assert response.status_code == status.HTTP_200_OK
        assert response.data["count"] == Plan.objects.count()

    # Can retrieve a single plan with GET request
    def test_retrieve_single_plan(self, client):
        client.login(username="admin", password="1qazxsw2")
        plan = baker.make(Plan)
        response = client.get(reverse("plan-detail", args=[plan.id]))
        assert response.status_code == status.HTTP_200_OK
        assert response.data["id"] == plan.id

    # Can create a new plan with POST request
    def test_create_new_plan(self, client):
        client.login(username="admin", password="1qazxsw2")
        # Arrange

        data = {
            "name": "Plan 1",
            "ueb": baker.make(Entity).id,
            "destiny": baker.make(Destination).id,
            "product_kind": baker.make(Classification).id,
            "year": datetime.today().year,
            "month": datetime.today().month,
            "quantity": 100,
            "measurement_unit": baker.make(MeasurementUnit).id,
        }
        response = client.post(reverse("plan-list"), data=data)
        assert response.status_code == status.HTTP_201_CREATED
        assert Plan.objects.filter(
            name="Plan 1"
        ).exists()  # Can create a new plan with POST request

    def test_create_new_plan_failed_for_invalid_year_and_month(self, client):
        client.login(username="admin", password="1qazxsw2")
        # Arrange
        # plan_viewset = PlanViewSet()
        ueb = baker.make(Entity)
        destiny = baker.make(Destination)
        product_kind = baker.make(Classification)
        measurement_unit = baker.make(MeasurementUnit)
        year = datetime.today().year
        month = datetime.today().month
        data = {
            "name": "Plan 1",
            "ueb": ueb.id,
            "destiny": destiny.id,
            "product_kind": product_kind.id,
            "year": year - 1,  # Invalid year
            "month": month,
            "quantity": 100,
            "measurement_unit": measurement_unit.id,
        }
        response = client.post(reverse("plan-list"), data=data)
        assert response.status_code == status.HTTP_400_BAD_REQUEST

        data["year"] = year
        data["month"] = month - 1  # Invalid month
        response = client.post(reverse("plan-list"), data=data)
        assert response.status_code == status.HTTP_400_BAD_REQUEST

        data["month"] = month
        response = client.post(reverse("plan-list"), data=data)
        assert response.status_code == status.HTTP_201_CREATED

    # Attempting to create a plan with a duplicate product, year, and month should return a 400 error
    def test_create_duplicate_plan(self, client):
        client.login(username="admin", password="1qazxsw2")
        # Arrange
        plan = baker.make(Plan, ueb=baker.make(Entity), destiny=baker.make(Destination))
        data = {
            "name": plan.name,
            "ueb": plan.ueb.id,
            "destiny": plan.destiny.id,
            "product_kind": plan.product_kind.id,
            "year": plan.year,
            "month": plan.month,
            "quantity": 100,
            "measurement_unit": plan.measurement_unit.id,
        }
        response = client.post(reverse("plan-list"), data=data)
        assert response.status_code == status.HTTP_400_BAD_REQUEST

    # Attempting to create a plan with a non-existent ueb or destiny should return a 400 error
    def test_create_plan_with_nonexistent_ueb_or_destiny(self, client):
        client.login(username="admin", password="1qazxsw2")
        # Arrange
        data = {
            "name": "Plan 1",
            "ueb": 9999,
            "destiny": 9999,
            "product_kind": baker.make(Classification).id,
            "year": datetime.today().year,
            "month": datetime.today().month,
            "quantity": 100,
            "measurement_unit": baker.make(MeasurementUnit).id,
        }
        response = client.post(reverse("plan-list"), data=data)
        assert response.status_code == status.HTTP_400_BAD_REQUEST

    # Returns a list of allowed products when given a valid request and pk
    def test_valid_request_and_pk_allowed_products(self, client):
        client.login(username="admin", password="1qazxsw2")
        plan = baker.make(Plan)
        child_classification = baker.make(Classification, parent=plan.product_kind)
        product_with_child_classification = baker.make(
            Product, classification=child_classification
        )
        product_with_same_classification_as_plan = baker.make(
            Product, classification=plan.product_kind
        )
        url = reverse("plan-allowed-products", args=[plan.pk])
        # Act
        response = client.get(url)
        # Assert
        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) == 2
        assert response.data[0]["id"] == product_with_same_classification_as_plan.id
        assert response.data[1]["id"] == product_with_child_classification.id

    # Returns an empty list when there are no allowed products for the given pk
    def test_no_allowed_products_for_pk(self, client):
        client.login(username="admin", password="1qazxsw2")
        plan = baker.make(Plan)
        url = reverse("plan-allowed-products", args=[plan.pk])

        # Act
        response = client.get(url)
        # Assert
        assert response.status_code == status.HTTP_404_NOT_FOUND

    # Returns a Response object with status code 404 when given an invalid pk
    def test_invalid_pk(self, client):
        client.login(username="admin", password="1qazxsw2")
        url = reverse("plan-allowed-products", args=[999])

        # Act
        response = client.get(url)

        # Assert
        assert response.status_code == status.HTTP_404_NOT_FOUND

    # Returns an empty list when there are no allowed products for the given pk and product_kind
    def test_no_allowed_products_for_pk_and_product_kind(self, client):
        client.login(username="admin", password="1qazxsw2")
        plan = baker.make(Plan)
        baker.make(Product)
        url = reverse("plan-allowed-products", args=[plan.pk])

        # Act
        response = client.get(url)
        # Assert
        assert response.status_code == status.HTTP_404_NOT_FOUND
